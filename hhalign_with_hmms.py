#!/usr/bin/python

"""
run_hhalign_with_input_hmms.py  Terry Farrah  May 2008 Sjolander lab

Align 2 HMMs using HHalign.
Do not let HHalign generate HMMs; instead, provide HMMs.
Optionally, use PSI-PRED to generate secondary structure and
  tell HHalign to use this info in its alignment.

Warnings:
  Must run in same dir as input hmms (because of SAM pickiness).
  Path for PSIPRED data is hard-coded.

SAM hmms tend to be here:
/home/ruchira/SHMM-SHMM/current_method/1a7w/1a7w.mod
/home/ruchira/SHMM-SHMM/current_method/1a7w/ascii_ghmm/1a7w.mod
Those on Ohana are generated using a  newer version of FlowerPower.

6/11/08
WORK REMAINING:
-- get psi-pred installed properly on ohana. Does psi-pred make use of
     a shell variable to tell it where the psi-pred data is? If so, set it.
     Get script/binary installed in /usr/bin.
-- remove  hardcoded path to script_dir (should be non-issue after above is done)
"""

import os, sys, glob, BPG_common.fasta
from optparse import OptionParser
from matchmaker.shmm_shmm_lib import *
from matchmaker.align_originals_via_shmms_and_score import *

script_dir = "/home/tfarrah/hmm-hmm"
psipred_data_dir = "/clusterfs/ohana/software/lib/psipred/data"


def add_ss_info_to_hmmer( hmm_filename, psipred_filename,
    out_filename):
  """ Input: 2) .horiz file generated by psipred suite
	      (specifically, by psipass2)
	     1) HMMER format HMM file
      Output: HMM file with psipred secondary structure records
	      added, specifically for input to HHalign
  """

  # open secondary structure  file
  psipred_file = open(psipred_filename, "r")

  # read all lines, saving Pred: and Conf: lines in two lists (after cleaving the prefixes)
  pred_lines = []
  conf_lines = []
  for line in psipred_file.readlines():
    if line.startswith("Pred:"): pred_lines.append(line[6:].strip())
    if line.startswith("Conf:"): conf_lines.append(line[6:].strip())

  # get sequence length from this data
  pred_seqlen = sum(map (len, pred_lines))
  conf_seqlen = sum(map (len, conf_lines))
  # if sequence length is zero, or if the two lengths differ, issue warning
  if pred_seqlen == 0:
    print >> sys.stderr, \
	"Error in file %s: no lines beginning with Pred:, or all such lines empty" \
	% (psipred_filename)
    sys.exit(0)
  if pred_seqlen != conf_seqlen:
    print >> sys.stderr, \
	"Error in file %s: lengths of Pred, Conf strings differ (%d v. %d)" \
	% (psipred_filename, pred_seqlen, conf_seqlen)
    sys.exit(0)

  # close .horiz file
  psipred_file.close()

  # open hmm file and output file
  hmm_file = open(hmm_filename, "r")
  if out_filename:
    out_file = open(out_filename, "w")
  else:
    out_file = sys.stdout

  # read and copy all lines to output file,
  # inserting SS info in appropriate place
  for line in hmm_file.readlines():
    if line.startswith("XT"):
      print >> out_file, "SSCIT", "Secondary structure info generated by PSIPRED"
      for ssline in pred_lines: print >> out_file, "SSPRD", ssline
      for ssline in conf_lines: print >> out_file, "SSCNF", ssline
    # skip any pre-existing SS info lines
    if line.startswith("SSPRD") or line.startswith("SSCNF"):
      continue
    # check to see that HMM length matches length of SS prediction
    if line.startswith("LENG"):
      hmm_seqlen = int (line[6:])
      if hmm_seqlen != pred_seqlen:
	print >> sys.stderr, \
	    "Warning: lengths of SS prediction, HMM differ (%d v. %d)" \
	    % (hmm_seqlen, pred_seqlen)
    print >> out_file, line.rstrip()

  # count match states while doing so

  # compare match state count with seq length
  #  and issue warning if different

  # close hmm file and output file
  hmm_file.close()
  out_file.close()


def extract_XY_alignment(seqX, seqY, file):

  # extract fasta format alignment from HHalign
  # standard output, adding X's and -'s to each end
  # (-ofas gives fasta output but leaves off residue #s)

  def add_to_seq(hhalign_line, seq):
    return seq + hhalign_line

  def prefix_X_and_dash(numX_for_Z, numX_for_W, seqZ, seqW):
    for i in range(0,numX_for_Z):
      seqZ = 'X' + seqZ
      seqW = '-' + seqW
    for i in range(0,numX_for_W):
      seqW = 'X' + seqW
      seqZ = '-' + seqZ
    return(seqZ, seqW)

  def append_X_and_dash(numX_for_Z, numX_for_W, seqZ, seqW):
    for i in range(0,numX_for_Z):
      seqZ = seqZ + 'X'
      seqW = seqW + '-'
    for i in range(0,numX_for_W):
      seqW = seqW + 'X'
      seqZ = seqZ + '-'
    return(seqZ, seqW)

  # Open file and read sequences
  hhalign_file = open(file, "r")
  lines = hhalign_file.readlines()
  seq_start = False
  seqZ = ""
  seqW = ""
  seqZ_start = None
  seqW_start = None
  for line in lines:
    line = line.strip()
    if line.startswith("No 1"):
      seq_start = True
      continue
    if seq_start:
      if (line.startswith("Q") or line.startswith("T")) \
            and not line[2:].startswith("Consensus") \
            and not line[2:].startswith("ss_pred"):
        (symbol, seqname, start_res_string, seq, end_res_string,
            seqlen_string) = line.split()
        start_res = int(start_res_string)
        end_res = int(end_res_string)
        seqlen = int(seqlen_string[1:-1])
        if symbol == "Q":
          seqZ = seqZ + seq
          if seqZ_start == None: seqZ_start = start_res
          seqZ_end = end_res
          seqZ_len = seqlen
        elif symbol == "T":
          seqW = seqW + seq
          if seqW_start == None: seqW_start = start_res
          seqW_end = end_res
          seqW_len = seqlen

  (seqZ, seqW) = prefix_X_and_dash(seqZ_start-1, seqW_start-1, seqZ, seqW)
  (seqZ, seqW) = append_X_and_dash(seqZ_len-seqZ_end, seqW_len-seqW_end, seqZ, seqW)

  # Create X-Y alignment according to W-Z alignment.
  alignment  =  align_four_way(seqX, seqZ, seqW, seqY)
  return alignment


def main_test():
  file = sys.argv[1]
  extract_XY_alignment(None, None, file)

def main():
  #====================
  # Process command line
  #====================
  parser = OptionParser()
  parser.add_option("--hmm1",
	dest="hmm1_filename",
	help="first input HMM in SAM (.mod) format. NOTE: all input files must be in the same directory, and the program needs to be run from that directory. ALSO NOTE: the number of match states in the HMMs must equal the sequence length of the corresponding seed",
	metavar="FILE")
  parser.add_option("--hmm2",
	dest="hmm2_filename",
	help="second input HMM in SAM (.mod) format",
	metavar="FILE")
  parser.add_option("--seq1",
	dest="seq1_filename",
	help="first seed seq in fasta (.fa) format",
	metavar="FILE")
  parser.add_option("--seq2",
	dest="seq2_filename",
	help="second seed seq in fasta (.fa) format",
	metavar="FILE")
  parser.add_option("-o", "--out",
	dest="out_filename",
	help="alignment output file",
	metavar="FILE")
  parser.add_option("-s", "--ss",
	dest="use_sec_struc",
	default=False,
	action="store_true",
	help="use and display secondary structure information",
	metavar="SS",)
  parser.add_option("-w", "--ssw",
	dest="sec_struc_weight",
	metavar="FRACTION",
	type="float",
	default=0.11,
	help="Weight to give secondary structure info; default =0.11")
  parser.add_option("-d", "--ppdata",
	dest="psipred_data_dir",
	metavar="DIR",
	default="/clusterfs/ohana/software/lib/psipred/data",
	help="Location of weight files for PSI-PRED, default /clusterfs/ohana/software/lib/psipred/data")

  (options, args) = parser.parse_args()

  # check that necessary options are given, and that values are valid
  # assign option values to variables
  hmm_filename = [None, None]
  seq_filename = [None, None]
  if not options.hmm1_filename:
    parser.error("Option --hmm1 required")
  else:
    hmm_filename[0] = options.hmm1_filename
  if not options.hmm2_filename:
    parser.error("Option --hmm2 required")
  else:
    hmm_filename[1] = options.hmm2_filename
  if not options.seq1_filename:
    parser.error("Option --seq1 required")
  else:
    seq_filename[0] = options.seq1_filename
  if not options.seq2_filename:
    parser.error("Option --seq2 required")
  else:
    seq_filename[1] = options.seq2_filename
  if options.out_filename:
    out_file = open(options.out_filename, "w")
  else:
    out_file = sys.stdout
  use_sec_struc = options.use_sec_struc
  sec_struc_weight = options.sec_struc_weight
  psipred_data_dir = options.psipred_data_dir

  runname = [None, None]



  for i in range(0,2):
    hmm_file_basename = os.path.basename(hmm_filename[i])
    #print hmm_file_basename
    runname[i] = os.path.splitext(hmm_file_basename)[0]
    #print runname[i]
    # Create HMMER format HMM
    # creates .con.hmm and .asc.mod files; we only need the first
    cmd =  "convert.pl %s" % hmm_filename[i]
    #print cmd
    os.system(cmd)
    hmmer_hmm_filename = os.path.splitext(hmm_filename[i])[0] + ".con.hmm"
    hhalign_hmm_filename = os.path.splitext(hmm_file_basename)[0] + ".hhm"

    if use_sec_struc:

      cmd = "sam2psi %s -i %s" % (runname[i], hmm_filename[i])
      #print cmd
      os.system(cmd)

      # we must run makemat on a copy of the .ckp file, because
      # it will overwrite the original
      cmd = "cp %s.ckp %s.makemat.ckp" % (runname[i], runname[i])
      #print cmd
      os.system(cmd)

      cmd = "echo %s.makemat.ckp > %s.pn" % (runname[i], runname[i])
      #print cmd
      os.system(cmd)

      cmd = "echo %s.cks > %s.sn" % (runname[i], runname[i])
      #print cmd
      os.system(cmd)

      cmd = "makemat -P %s" % (runname[i])
      #print cmd
      os.system(cmd)

      # the name of the makemat output file is stored in a file
      makemat_matrix_record_filename = runname[i] + ".mn"
      makemat_matrix_record_file = open(makemat_matrix_record_filename, "r")
      makemat_matrix_filename = makemat_matrix_record_file.readline().strip()
      #print makemat_matrix_filename
      cmd = "cp %s %s.mtx" % (makemat_matrix_filename, runname[i])
      #print cmd
      os.system(cmd)
      

      cmd ="psipred %s.mtx %s/weights.dat %s/weights.dat2 %s/weights.dat3 %s/weights.dat4 > %s.ss" % \
	 (runname[i], psipred_data_dir, psipred_data_dir, psipred_data_dir,
	  psipred_data_dir, runname[i])
      #print cmd
      os.system(cmd)

      cmd = "psipass2 %s/weights_p2.dat 1 1.0 1.0 %s.ss2 %s.ss > %s.horiz" % \
	  (psipred_data_dir, runname[i], runname[i], runname[i])
      #print cmd
      os.system(cmd)

      # we want to make this into a function
      # instead of a separate script
      #cmd = "%s/add_ss_info_to_hmmer.py -i %s.con.hmm -s %s.horiz -o %s.ss.hmm" % \
	 #(script_dir, runname[i], runname[i], runname[i])
      #print cmd
      #os.system(cmd)
      add_ss_info_to_hmmer("%s.con.hmm" % runname[i], "%s.horiz" % runname[i],
          "%s.ss.hmm" % runname[i])

      # convert HMMER format to HHalign (.hhm) format
      # optional but increases performance according to HHsearch doc
      # however in my experience when HHalign is run with the resulting
      # .hhm files instead of the .hmm files, it does not seem to make
      # use of the secondary structure information.
      #cmd =  "hhmake -i %s.ss.hmm -o %s.ss.hhm" % (runname[i], runname[i])
      #print cmd
      #os.system(cmd)
    
    else:

      pass   #see above for why
      # convert HMMER format to HHalign (.hhm) format
      # optional but increases performance according to HHsearch doc
      #cmd =  "hhmake -i %s.con.hmm -o %s.hhm" % (runname[i], runname[i])
      #print cmd
      #os.system(cmd)

  pair = "%s_%s" % (runname[0], runname[1])

  if use_sec_struc:
    hhalign_output_base_filename = "%s.ss.hhalign" % (pair)
    hhalign_alignment_filename = "%s.align" % (hhalign_output_base_filename)
    cmd = "hhalign -i %s.ss.hmm  -t %s.ss.hmm -ssw %f -o %s.align -ofas %s.fa > /dev/null" % \
       (runname[0], runname[1], sec_struc_weight, hhalign_output_base_filename, hhalign_output_base_filename)
    #print cmd
    os.system(cmd)

  else:
    hhalign_output_base_filename = "%s.hhalign" % (pair)
    hhalign_alignment_filename = "%s.align" % (hhalign_output_base_filename)
    cmd = "hhalign -i %s.con.hmm  -t %s.con.hmm  -o %s.align -ofas %s.fa > /dev/null" % \
       (runname[0], runname[1], hhalign_output_base_filename, hhalign_output_base_filename)
    #print cmd
    os.system(cmd)

  # get X and Y sequences
  seqX = BPG_common.fasta.ReadOneSequence(seq_filename[0])
  seqY = BPG_common.fasta.ReadOneSequence(seq_filename[1])

  # alignment is a 4-tuple of equal-length strings: X,Z,W,Y
  alignment = extract_XY_alignment(seqX, seqY, hhalign_alignment_filename)
  print >> out_file, ">%s" % runname[0]
  print >> out_file, alignment[0]
  print >> out_file, ">%s" % runname[1]
  print >> out_file, alignment[3]

  # to activate the below, need to store alignment in file, and need reference alignment
  # CS_score_filename = "%s_CS.out" % pair
  # compute_sp_cs_score (alignment_filename, reference_alignment_filename,
     #CS_score_filename)

if __name__ == "__main__":
  main()
